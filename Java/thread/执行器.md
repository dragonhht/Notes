> - 自Java5开始，Java提供了一套机制(线程执行器)用于分离任务的创建和执行  
> - 执行器会尝试使用线程池中的线程来执行这个任务。避免了不断创建和销毁线程导致的性能开销

##   创建线程池的方法(该处讲述的方法都为`java.util.concurrent.Executors`的方法)

-   `newFixedThreadPool(int nThreads)`：用于创建固定大小的线程池

    -   传入的参数表示为线程池中最大的线程数
    
    -   当发送的任务大于该数量时，线程池中只会创建该数量的线程，剩下的任务将会被阻塞，直到有空闲的线程可用
    
    -   创建方式: `ExecutorService executor = Executors.newFixedThreadPool(3);`

-   `newSingleThreadExecutor()`：用于创建单线程化的线程池

    -   在该线程池中只有一个工作的线程
    
    -   该线程池可保证`任务会按任务的提交顺序进行`
    
    -   创建方式: `ExecutorService executor = Executors.newSingleThreadExecutor();`

-   `newCachedThreadPool()`：用于创建一个可缓存的线程池

    -   该线程池的`工作线程的创建数量几乎没有限制`
    
    -   当线程池中没有可用的线程时，新添加的任务将会再创建一个线程运行
    
    -   运行完的任务，在任务运行完的`60s`内不会被回收，当有新任务时将会重用这些没被回收的线程

    -   创建方式: `ExecutorService executor = Executors.newCachedThreadPool();`

-   `newScheduledThreadPool(int corePoolSize)`：用于创建一个定长的且支持定时及周期性运行任务的线程池

    -   传入的参数表示为线程池中最大的线程数

    -   创建方法: `ScheduledExecutorService executor = Executors.newScheduledThreadPool(3);`

    -   使用`schedule(Runnable command, long delay, TimeUnit unit)`方法提交任务时，可让任务延迟执行，如下延迟1分钟执行示例: 

        ```java
        // 定义执行器，创建一个缓存线程池
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(3);
        // 提交任务
        executor.schedule(() -> System.out.println("hello: " + new Date()), 1, TimeUnit.SECONDS);
        // 关闭执行器资源
        executor.shutdown();
        ```

    -   使用`scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)`方法提交任务，可让任务延迟并周期性执行，如下让任务延迟一秒后没3秒执行一次:

        ```java
        // 定义执行器，创建一个缓存线程池
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(3);
        // 提交任务
        executor.scheduleAtFixedRate(() -> System.out.println("hello: " + new Date()), 1, 3, TimeUnit.SECONDS);
        // 周期性执行任务时不要关闭执行器，否则不会周期性执行
        //executor.shutdown();
        ```

-   `newSingleThreadScheduledExecutor()`：功能与`newScheduledThreadPool(int corePoolSize)`方法创建的线程池类似，只是该方法创建的是单例化的线程池，即在该线程池中只有一个工作的线程

-   `newWorkStealingPool()`：可创建一个拥有多个任务队列的线程池

    -   该方法实在`Java1.8`增加的方法
    
    -   它是线程池类`ForkJoinPool`的扩展
    
    -   该线程池能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中

    -   创建方式：`ExecutorService executor = Executors.newWorkStealingPool();`

##   常用方法

-   `execute`：用于将任务提交给执行器执行

-   `submit`：功能同`execute`，但该方法有返回值

-   `shutdown()`：用于关闭执行器资源，执行器会拒绝后面的任务提交，并等待线程池中的任务结束后关闭资源

-   `shutdownNow()`：立即关闭执行器，不再执行线程池中等待执行的任务，正在执行的任务将会继续

-   `isShutdown()`：调用了`shutdown()`后该方法将返回`true`

-   `awaitTermination(long timeout, TimeUnit unit)`：该方法会阻塞调用执行器的线程，并等待执行器内任务完成会到达指定的时间

-   `invokeAny(Collection<? extends Callable<T>> tasks)`：该方法返回到值为第一个完成的任务返回的值

-   `invokeAll(Collection<? extends Callable<T>> tasks)`：该任务的返回值为所有任务完成的结果

##  使用示例

-   基本使用方法

```java
public class ExecutorFirstTest {

    public static void main(String[] args) {
        // 定义执行器，创建一个缓存线程池
        ExecutorService executor = Executors.newCachedThreadPool();
        // 将任务交给执行器
        for (int i = 0; i < 10; i++) {
            executor.execute(() -> {
                System.out.println(Thread.currentThread().getName() + ": 任务开始执行");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + ": 任务结束");
            });
        }
        // 关闭执行器资源
        executor.shutdown();
    }

}
```