# 1、信号量：`Semaphore`

> 信号量是一个计数器，用来保护一个或多个共享资源的访问。当线程访问一个一个共享资源时，它必须得先获取信号量，如果信号量大于0，则信号量减一，该线程允许访问共享资源。当信号量等于0,则线程将会被置于休眠，直到信号量大于0  

-   注意：`当线程用完某个共享资源后，信号量必须释放，释放操作将会是信号量的内部计数器加1`

-   使用`二进制信号量`控制队列中数据的添加和获取的同步(此处使用`公平模式`，在非公平模式下，多个死循环线程中出现信号量一直被一个线程占用的情况)

```java
public class SemaphoreTest {

    /** 声明一个信号量对象. */
    private Semaphore semaphore;
    /** 存储数据. */
    private LinkedList<Double> storage = new LinkedList<>();
    /** 存储的最大数量. */
    private int maxSize = 20;

    public SemaphoreTest() {
        // 此处传入的参数为1，则该信号量为二进制信号量，即信号量的计数器的值只有0和1
        // 第二个参数表示是否公平
        this.semaphore = new Semaphore(1, true);
    }

    /**
     * 添加
     * @param d
     */
    public void add(Double d) {
        try {
            // 获取信号量
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName() +": add start");
            if (this.storage.size() < this.maxSize) {
                this.storage.add(d);
            }
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() +": add end");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放信号量
            semaphore.release();
        }
    }

    /**
     * 获取
     */
    public Double get() {
        try {
            // 获取信号量
            semaphore.acquire();
            double d = 0.0;
            System.out.println(Thread.currentThread().getName() +": get start");
            if (this.storage.size() > 0 ) {
                d = this.storage.poll();
            }
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() +": get end");
            return d;
        } catch (InterruptedException e) {
            e.printStackTrace();
            return 0.0;
        } finally {
            // 释放信号量
            semaphore.release();
        }
    }

    public static void main(String[] args) {
        SemaphoreTest test = new SemaphoreTest();
        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                while (true) {
                    test.add(Math.random());
                }
            }).start();
        }

        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                while (true) {
                    System.out.println(test.get());
                }
            }).start();
        }
    }

}
```

-   除二进制信号量外，信号量还可以让实现被多个线程同时访问的临界区

# 2、使用`CountDownLatch`等待并发事件完成

-   `CountDownLatch`可以完成一组正在其他线程中执行的操作前，允许他一直等待

-   实例：在20个线程完全准备好前，让线程等待

```java
public class CountDownLatchTest {

    public static void main(String[] args) {
        int size = 20;
        // 创建CountDownLatch对象
        CountDownLatch latch = new CountDownLatch(size);
        Lock lock = new ReentrantLock();
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                System.out.println("等待线程全部准备...");
                try {
                    try {
                        // 为了 latch.getCount() 顺序所以加锁控制
                        lock.lock();
                        // 减一操作，表示该线程以准备完成
                        latch.countDown();
                        System.out.println("还有 " + latch.getCount() + " 个线程需准备");
                    } finally {
                        lock.unlock();
                    }
                    // 等待其他线程准备
                    latch.await();
                    System.out.println(Thread.currentThread().getName() + ": 准备完成, 开始执行任务...");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }

}
```